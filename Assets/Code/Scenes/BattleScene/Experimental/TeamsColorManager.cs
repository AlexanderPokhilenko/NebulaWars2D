using System;
using Code.Common;
using System.Collections.Generic;
using System.Linq;
using Code.Common.Storages;
using UnityEngine;

namespace Code.Scenes.BattleScene.Experimental
{
    public class TeamsColorManager : Singleton<TeamsColorManager>
    {
        protected override bool DontDestroy { get; } = true;
        private readonly List<Material> currentMaterials = new List<Material>(distinctSets.Max(arr => arr.Length));
        private readonly Dictionary<int, Color[]> autoGenerated = new Dictionary<int, Color[]>(distinctSets.Length);
        private static readonly Color[][] distinctSets = { //Сгенерированы на: https://mokole.com/palette.html
            new []
            {
                Color.red, // Красный всегда должен быть в самом начале
                UIntToColor(0xFFffd700), UIntToColor(0xFF7fff00), UIntToColor(0xFF00ffff), UIntToColor(0xFF0000ff), UIntToColor(0xFFff69b4),
                UIntToColor(0xFFffe4c4), UIntToColor(0xFF8b4513), UIntToColor(0xFF006400), UIntToColor(0xFF4682b4), UIntToColor(0xFF4b0082)
            }
        };

        private ColorsMode _colorsMode;
        public ColorsMode TeamsColorsMode
        {
            get => _colorsMode;
            set
            {
                _colorsMode = value;
                UpdateMaterialsColors();
            }
        }

        protected override void Awake()
        {
            base.Awake();
            _colorsMode = (ColorsMode)PlayerPrefs.GetInt(nameof(TeamsColorsMode), (int) ColorsMode.Distinct);
        }

        private void OnDestroy()
        {
            foreach (var material in currentMaterials) DestroyImmediate(material);
            PlayerPrefs.SetInt(nameof(TeamsColorsMode), (int)_colorsMode);
            PlayerPrefs.Save();
        }

        public List<Material> GetOutlineMaterials(int count)
        {
            if (currentMaterials.Count > count)
            {
                for (var i = count; i < currentMaterials.Count; i++)
                {
                    DestroyImmediate(currentMaterials[i]);
                }
                currentMaterials.RemoveRange(count, currentMaterials.Count - count);
            }
            else
            {
                var outlineShader = Shader.Find("Sprites/Outline");
                while (currentMaterials.Count < count)
                {
                    var material = new Material(outlineShader);
                    material.SetFloat("_Thickness", 1f);
                    currentMaterials.Add(material);
                }
            }

            UpdateMaterialsColors();

            return currentMaterials;
        }

        private void UpdateMaterialsColors()
        {
            var count = currentMaterials.Count;
            var colors = GetColors(count);
            for (var i = 0; i < count; i++)
            {
                currentMaterials[i].SetColor("_SolidOutline", colors[i]);
            }
        }

        public Color[] GetColors(int count)
        {
            switch (TeamsColorsMode)
            {
                case ColorsMode.None:
                    var transparentColors = new Color[count];
                    for (var i = 0; i < count; i++) transparentColors[i] = Color.clear;
                    return transparentColors;
                case ColorsMode.RedAndGreen:
                    var redAndGreenColors = new Color[count];
                    for (var i = 0; i < count; i++) redAndGreenColors[i] = Color.red;
                    var models = MyMatchDataStorage.Instance.GetMatchModel().PlayerModels;
                    var accountId = PlayerIdStorage.AccountId;
                    var index = Array.FindIndex(models, model => model.AccountId == accountId);
                    redAndGreenColors[index + 1] = Color.green; // +1, потому что у нас по нулевому индексу нейтрально-враждебные
                    return redAndGreenColors;
                case ColorsMode.Distinct:
                    foreach (var colorSet in distinctSets) if (colorSet.Length == count) return colorSet;
                    Debug.LogError($"Не обнаружено подходящего набора цветов в {nameof(TeamsColorManager)}.{nameof(distinctSets)}!");
                    break;
                //case ColorsMode.AutoGeneration:
                //    break;
                //default:
                //    throw new ArgumentOutOfRangeException();
            }
            // Иначе возвращаем сгенерированный набор
            return GetGeneratedSet(count);
        }

        private Color[] GetGeneratedSet(int count)
        {
            if (autoGenerated.TryGetValue(count, out var generatedSet)) return generatedSet;
            
            generatedSet = new Color[count];
            for (var i = 0; i < count; i++)
            {
                generatedSet[i] = Color.HSVToRGB((float) i / count, 1f, 1f);
            }

            autoGenerated.Add(count, generatedSet);
            return generatedSet;
        }

        private static Color UIntToColor(uint color)
        {
            var a = (byte)(color >> 24) / (float)byte.MaxValue;
            var r = (byte)(color >> 16) / (float)byte.MaxValue;
            var g = (byte)(color >> 8) / (float)byte.MaxValue;
            var b = (byte)(color/* >> 0*/) / (float)byte.MaxValue;
            return new Color(r, g, b, a);
        }

        public enum ColorsMode : byte
        {
            None,
            RedAndGreen,
            Distinct,
            AutoGeneration
        }
    }
}